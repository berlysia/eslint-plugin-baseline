# ESLint Baseline Plugin 実装状況

## 進捗状況

### 完了済み

- [x] 基本設計の確立
  - [x] 設計パターンの検討と決定（ハイブリッドアプローチ採用）
  - [x] 設定構造の設計
  - [x] 基本設計ドキュメントの作成

### 進行中

- [ ] コア機能の実装
  - [ ] 各ルールの実装
    - 実装対象のルールは多数あるため、進捗は `npm run agent:rules:next` コマンドで確認できます
    - 実装プロセスは「ルール開発のガイドライン」セクションを参照してください
  - [ ] 統合ルールの実装
  - [ ] 設定ファクトリ関数の実装
  - [ ] ディテクターの実装
  - [ ] キャッシング機構の実装

### 今後の予定

- [ ] 追加機能

  - [ ] 個別ルールのテンプレート作成
  - [ ] パフォーマンス最適化
  - [ ] エラーメッセージのローカライズ
  - [ ] CSS機能のサポート（別プラグインとして）

- [ ] ドキュメント
  - [ ] API リファレンス
  - [ ] 設定ガイド
  - [ ] 貢献ガイド
  - [ ] プラグイン分割ガイドライン

## ルール開発のガイドライン

### 1. テストの実装

- 各ルールには対応するテストを実装する
- テストは以下のパターンを含むべき:
  - 正常系: 対象の機能が十分にサポートされている場合
  - 異常系: 対象の機能がサポートされていない場合
  - エッジケース: 特殊な状況での動作
- 常に実装上で検知すべきASTの種別の特定には次のツールを使用:
  - `npm run agent:ast:acorn` でASTを生成
  - `npm run agent:ast:typescript` でTypeScriptのASTを生成

### 2. 機能の判定方法

- シンタックスレベルの機能は、その構文で判定:
  - 例: `import` 文は `ImportDeclaration` ノードで判定
  - 例: `class` 文は `ClassDeclaration` ノードで判定
  - 例: `async` 関数は `FunctionDeclaration` ノードで判定
- オブジェクトやメンバーの存在確認は型情報を使用:
  - 例: `AggregateError` は `AggregateError` コンストラクタの参照で判定する。型的には `AggregateErrorConstructor` のような型が対応していることが多い。
  - 例: `AggregateError.prototype.errors` は `.errors` へのアクセスのレシーバが `AggregateError` 型のオブジェクトかどうかで判定

### 3. コード品質と実装原則

- 最小限かつ効率的な実装を心がける:
  - 重複するハンドラーはできるだけ避ける
  - 同じノードに対して複数回のエラー報告を避ける
  - 複雑なロジックは共通の関数に抽出し、可読性を高める
  - 共通の検証ロジックは関数化する
  - 1箇所でしか使われない処理は、関数化せずに直接記述する
  - 同じノードに複数回マッチするようなセレクタは可能な限り回避する
- ASTの構造を理解し、最も効率的な検出方法を選択する:
  - メソッドの参照は基本的に`MemberExpression`で捕捉できる
  - メソッド呼び出し自体や引数は基本的に`CallExpression`で捕捉できる
  - 抽象度の高い検出ではなく、具体的な構文要素で検出する
- ESLintセレクタを活用して効率的に実装する
- 型チェックを活用して堅牢な実装を行う
- コードのフォーマットと読みやすさに配慮する

### 4. 実装上の制約

- seedPathのファイルへの参照をルール内に持つことは禁止
- `createInstanceMethodExistenceRule` や `createStaticMethodExistenceRule` の引数は変更禁止
- 特定のテストケースのシンボル名やコードに直接依存した実装は禁止
  - それぞれのテストケースが示す代表的な例から、真にマッチすべきASTのパターンや、プローブとすべき型の判定を使い、ルールを実装しなければならない
- エラー処理目的での広範囲にわたるtry-catchの利用は禁止
  - 実行時エラーの可能性があるなら、それが起きないように型レベルで検証しなければならない

### 5. 実装フロー

- テストを実装しながら開発を進める
- 実装の完了には `npm run agent:check` が正常終了することを確認する
  - `npm run agent:check` は以下の3つのコマンドを実行します:
    - `npm run test` でテストを実行し、動作を確認
    - `npm run typecheck` で型チェックを実行
    - `npm run lint` でコードの整形と静的解析を実行
      - 警告の場合も対処をしなければなりません
- 3つのコマンドの正常終了を確認したら、`src/index.ts` にルールを追加
- **必ず** 作業内容をコミットする

### 6. 基本機能と拡張機能の分割ルール

- 基本機能（例：`Array.prototype.toLocaleString`、`AggregateError`）とその拡張機能（例：`Array.prototype.toLocaleString.locales_parameter`、`AggregateError.serializable_object`）が別々のルールとして実装される場合は、以下のガイドラインに従ってください：

  - 基本機能のルール：機能の基本的な振る舞いのみをテスト。拡張機能や特殊パラメータを使用しないテストケースのみを含める。
  - 拡張機能のルール：特定の拡張機能（特殊パラメータや追加プロパティなど）を使用するケースのみをテスト。基本機能のテストと重複しないようにする。
  - 関連ルール間でのテストの重複を避ける。各ルールは明確な責任領域を持つべき。

- 拡張機能のルールのテストでは、拡張機能を使用しないケースは `validOnlyCodes` に含め、常に有効とマークする。

- 実装順序：
  - 関連するルールを実装する場合は、まず基本機能のルールを実装してから拡張機能のルールに進む。
  - 最初のルールを実装した後、テストケースが適切に分離されていることを確認してから次のルールに進む。

## テストケースのガイドライン

### テストケースの構造

1. **基本のテスト構造**

   - 各ルールのテストは `createSimpleRuleTest` 関数を使用して実装
   - テストは以下の要素を含む必要があります：
     - `rule`: テスト対象のESLintルール
     - `seed`: ルールの設定情報を含むオブジェクト
     - `codes`: 指定された条件下で適切または不適切と判断されるコード例
     - `validOnlyCodes`: 常に適切と判断されるコード例（オプション）
     - `validOption`: 全てのコードが適切になる設定（例：新しい日付設定）
     - `invalidOption`: `codes` 内のコードが不適切になる設定（例：古い日付設定）

2. **テストケースの選定基準**

   - メソッドの基本的な使い方を示す例
   - compatKeyが特徴的な使い方を示している場合にのみ、その特徴的な使い方を示す例
   - 異なる初期化方法での使用例
   - メソッドのプロトタイプを直接利用する呼び出し方法
   - 非対象オブジェクトの類似メソッド

3. **テスト条件の設定**
   - 通常、将来の日付（例: 2025年）でwidely supportedとなる条件を正常系として
   - 過去の日付（例: 機能が導入される前の日付）を異常系として

### 複数ルールにまたがる機能のテスト

1. **責任の明確な分離**

   - 複数のルールにまたがる機能（基本機能とその拡張機能）をテストする場合は、各ルールのテストの責任領域を明確に分離する。
   - テストの重複を避け、各ルールが独自の側面をテストするようにする。

2. **テストケースの配置**

   - 基本機能のテスト：拡張機能を使用しない基本的な使用方法をテスト
   - 拡張機能のテスト：その拡張機能を使用するケースのみをテスト
   - 両方のテストに、それぞれが対象としない機能をテストするケースを `validOnlyCodes` として含める

3. **コメントの活用**
   - テストケースには明確なコメントを含め、テストの意図を示す

## エージェント向け開発用ツール

### 開発用コマンド

- `npm run format` - Prettierを使用してコードを整形
  - プロジェクト全体のコードスタイルを統一するために使用します
  - コミット前に実行することを推奨します

### 特殊なケースの処理

一部のプロパティやメソッドは典型的な命名規則に従わず、インスタンスメンバーなのかstaticメンバーなのかを自動で判別することが難しい場合があります。例えば、`ArrayBuffer.prototype.detached` や `ArrayBuffer.prototype.byteLength` はインスタンスプロパティですが、ルール名に「prototype」が含まれていません。

これらの特殊ケースを対処するには以下の3つの戦略を使用しています：

1. **メタデータファイルによる明示的な修正**：

   - `scripts/data/property_corrections.json` ファイルに特殊ケースの修正情報を記録
   - このファイルは以下の形式でプロパティ情報を定義します：

   ```json
   {
   	"javascript.builtins.ArrayBuffer.detached": {
   		"propertyType": "instance",
   		"concern": "ArrayBuffer.prototype.detached",
   		"notes": "ruleName内に'prototype'がなくてもインスタンスプロパティ"
   	}
   }
   ```

2. **URLからの推論**：
   - MDN URLと仕様URLからプロパティタイプを推論
   - 例えば、URLに「prototype」が含まれている場合はインスタンスプロパティと判断
   - 仕様URLに「sec-get」や「sec-set」が含まれている場合はインスタンスプロパティと判断
3. **ルール名による判断（フォールバック）**：
   - ルール名の中に「prototype」が含まれている場合はインスタンスプロパティと判断
   - それ以外の場合は静的プロパティと判断

これらの戦略を組み合わせることで、ルール生成時に正確なバリデータタイプを選択できるようになっています。特殊なケースを発見した場合は、メタデータファイルに追加することで対応できます。

### ASTの解析

- `npm run agent:ast:acorn` - Acornを使用してASTを生成

  - `--code "<コード>"` コードを文字列で与える
  - `--jsx` JSXを有効にする
  - 出力: AST（JSON形式）

- `npm run agent:ast:typescript` - TypeScript ESTreeを使用してASTを生成
  - `--code "<コード>"` コードを文字列で与える
  - `--jsx` JSXを有効にする
  - 出力: AST（JSON形式）と型情報

### ルール開発

- `npm run agent:rules:next` - 次に実装するルールの情報を取得

  - 出力:
    - `ruleName`: 実装すべきルール名
    - `description`: ルールの説明
    - `seedPath`: 機能のサポート状況データへのパス
  - 注意: すべてのルールが実装済みの場合はエラーを返します

- `npm run agent:rules:scaffold` - 指定されたルール名で新しいルールの雛形を生成

  - `--ruleName "<ルール名>"` ルール名を指定
  - `--methodKind <instance|static>` メソッドの種類を指定
  - 生成されるファイル:
    - `src/rules/<ルール名>.ts`: ルールの実装
    - `test/rules/<ルール名>.test.ts`: テストファイル

- `npm run agent:rules:add <compatKey>` - src/rules/index.tsにルールを登録
  - これにより、ルールのインポートと登録が自動的に行われます
